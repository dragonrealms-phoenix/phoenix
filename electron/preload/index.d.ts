import type { IpcRendererEvent } from 'electron';
/**
 * The index.d.ts file is auto-generated by the build process.
 */
declare const appAPI: {
  ping: () => Promise<string>;
  /**
   * Logs a message to the main process.
   */
  log: (options: {
    scope: string;
    level: 'error' | 'warn' | 'info' | 'debug' | 'trace';
    message: string;
    timestamp: Date;
    data?: Record<string, any>;
  }) => Promise<void>;
  /**
   * Add or update credentials for a play.net account.
   */
  saveAccount: (options: {
    accountName: string;
    accountPassword: string;
  }) => Promise<void>;
  /**
   * Remove credentials for a play.net account.
   */
  removeAccount: (options: { accountName: string }) => Promise<void>;
  /**
   * List added accounts.
   */
  listAccounts: () => Promise<
    Array<{
      accountName: string;
    }>
  >;
  /**
   * Add or update a character for a given play.net account and game instance.
   */
  saveCharacter: (options: {
    accountName: string;
    characterName: string;
    gameCode: string;
  }) => Promise<void>;
  /**
   * Remove a character for a given play.net account and game instance.
   */
  removeCharacter: (options: {
    accountName: string;
    characterName: string;
    gameCode: string;
  }) => Promise<void>;
  /**
   * List added characters.
   */
  listCharacters: () => Promise<
    Array<{
      accountName: string;
      characterName: string;
      gameCode: string;
    }>
  >;
  /**
   * Play the game with a given character.
   * This app can only play one character at a time.
   * Use the `onMessage` API to receive game data.
   * Use the `sendCommand` API to send game commands.
   */
  playCharacter: (options: {
    accountName: string;
    characterName: string;
    gameCode: string;
  }) => Promise<void>;
  /**
   * Quit the game with the currently playing character, if any.
   * Similar to sending the `quit` command to the game but awaits
   * the game to confirm the quit before resolving.
   */
  quitCharacter: () => Promise<void>;
  /**
   * Sends a command to the game as the currently playing character.
   * Use the `onMessage` API to receive game data.
   */
  sendCommand: (command: string) => Promise<void>;
  /**
   * Allows the renderer to subscribe to messages from the main process.
   * Returns an unsubscribe function, useful in react hook cleanup functions.
   */
  onMessage: (
    channel: string,
    callback: (event: IpcRendererEvent, ...args: Array<any>) => void
  ) => OnMessageUnsubscribe;
  /**
   * Allows the renderer to unsubscribe from messages from the main process.
   * Removes all listeners added by the `onMessage` API for a channel.
   */
  removeAllListeners(channel: string): void;
};
declare global {
  type OnMessageUnsubscribe = () => void;
  type TypeOfAppAPI = typeof appAPI;
  type AppAPI = {
    [K in keyof TypeOfAppAPI]: TypeOfAppAPI[K];
  };
  interface Window {
    api: AppAPI;
  }
}
export type { AppAPI };
